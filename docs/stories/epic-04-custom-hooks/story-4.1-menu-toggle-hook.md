# Story 4.1: useMenuToggle Hook ÏÉùÏÑ±

## üìù Story Ï†ïÎ≥¥
- **Epic**: Epic 4 - Custom Hooks & Logic Abstraction
- **Ìè¨Ïù∏Ìä∏**: 5Ï†ê
- **ÏÉÅÌÉú**: üìù To Do
- **ÏòàÏÉÅ ÏÜåÏöîÏãúÍ∞Ñ**: 1.5Ïùº
- **Ïö∞ÏÑ†ÏàúÏúÑ**: High (Header Ïª¥Ìè¨ÎÑåÌä∏ Í∞ÑÏÜåÌôî ÌïÑÏöî)

## üéØ Story Î™©Ìëú
Header Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÌïòÎìúÏΩîÎî©Îêú Î©îÎâ¥ ÌÜ†Í∏Ä Î°úÏßÅÏùÑ Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú Custom HookÏúºÎ°ú Ï∂îÏ∂ú

## üë§ ÏÇ¨Ïö©Ïûê Ïä§ÌÜ†Î¶¨
**As a** Í∞úÎ∞úÏûê  
**I want** Î©îÎâ¥ ÌÜ†Í∏Ä Í∏∞Îä•Ïù¥ Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•Ìïú HookÏúºÎ°ú Î∂ÑÎ¶¨ÎêòÏñ¥  
**So that** Header Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Í∞ÑÏÜåÌï¥ÏßÄÍ≥† Îã§Î•∏ Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑúÎèÑ Í∞ôÏùÄ Î°úÏßÅÏùÑ ÏÇ¨Ïö©Ìï† Ïàò ÏûàÎã§

## üîç ÌòÑÏû¨ ÏÉÅÌô© Î∂ÑÏÑù

### Header.tsxÏùò Í∏∞Ï°¥ Î°úÏßÅ
```typescript
// src/components/Header.tsx
function Header() {
  const [isMenuOpen, setIsMenuOpen] = useState(false);

  // Î≥µÏû°Ìïú Ïô∏Î∂Ä ÌÅ¥Î¶≠ Í∞êÏßÄ Î°úÏßÅ
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (isMenuOpen) {
        const target = event.target as HTMLElement;
        const menuButton = document.querySelector('[data-menu-button]');
        const menuOverlay = document.querySelector('[data-menu-overlay]');
        
        if (menuButton && !menuButton.contains(target) && 
            menuOverlay && !menuOverlay.contains(target)) {
          setIsMenuOpen(false);
        }
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, [isMenuOpen]);

  // ESC ÌÇ§ Ï≤òÎ¶¨ (ÌòÑÏû¨ ÏóÜÏßÄÎßå Ï∂îÍ∞Ä ÌïÑÏöî)
  // Ìè¨Ïª§Ïä§ Ìä∏Îû© (ÌòÑÏû¨ ÏóÜÏßÄÎßå Ï∂îÍ∞Ä ÌïÑÏöî)
  
  return (
    // JSX...
  );
}
```

### Î¨∏Ï†úÏ†ê Î∂ÑÏÑù
1. **Î≥µÏû°ÏÑ±**: Header Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä Î©îÎâ¥ Î°úÏßÅÏúºÎ°ú Ïù∏Ìï¥ Î≥µÏû°Ìï¥Ïßê
2. **Ïû¨ÏÇ¨Ïö© Î∂àÍ∞Ä**: Îã§Î•∏ Ïª¥Ìè¨ÎÑåÌä∏ÏóêÏÑú ÎèôÏùºÌïú Î©îÎâ¥ Í∏∞Îä• ÌïÑÏöî Ïãú ÏΩîÎìú Ï§ëÎ≥µ
3. **Ï†ëÍ∑ºÏÑ± Î∂ÄÏ°±**: ÌÇ§Î≥¥Îìú ÎÑ§ÎπÑÍ≤åÏù¥ÏÖò Î∞è Ìè¨Ïª§Ïä§ Í¥ÄÎ¶¨ ÎØ∏Ìù°
4. **ÌÖåÏä§Ìä∏ Ïñ¥Î†§ÏõÄ**: Ïª¥Ìè¨ÎÑåÌä∏ÏôÄ Î°úÏßÅÏù¥ Î∞ÄÏ†ëÌïòÍ≤å Í≤∞Ìï©ÎêòÏñ¥ Îã®ÏúÑ ÌÖåÏä§Ìä∏ Ïñ¥Î†§ÏõÄ

## üèóÔ∏è useMenuToggle Hook ÏÑ§Í≥Ñ

### Hook Ïù∏ÌÑ∞ÌéòÏù¥Ïä§
```typescript
interface UseMenuToggleOptions {
  initialOpen?: boolean;
  closeOnOutsideClick?: boolean;
  closeOnEscape?: boolean;
  trapFocus?: boolean;
  onOpen?: () => void;
  onClose?: () => void;
}

interface UseMenuToggleReturn {
  isOpen: boolean;
  open: () => void;
  close: () => void;
  toggle: () => void;
  menuRef: React.RefObject<HTMLElement>;
  buttonRef: React.RefObject<HTMLElement>;
  getMenuProps: () => MenuProps;
  getButtonProps: () => ButtonProps;
}

function useMenuToggle(options?: UseMenuToggleOptions): UseMenuToggleReturn;
```

### Íµ¨ÌòÑ Í≥ÑÌöç

#### 1. Í∏∞Î≥∏ ÏÉÅÌÉú Í¥ÄÎ¶¨
```typescript
// src/hooks/useMenuToggle.ts
import { useState, useRef, useEffect, useCallback } from 'react';

export function useMenuToggle(options: UseMenuToggleOptions = {}) {
  const {
    initialOpen = false,
    closeOnOutsideClick = true,
    closeOnEscape = true,
    trapFocus = false,
    onOpen,
    onClose,
  } = options;

  const [isOpen, setIsOpen] = useState(initialOpen);
  const menuRef = useRef<HTMLElement>(null);
  const buttonRef = useRef<HTMLElement>(null);

  const open = useCallback(() => {
    setIsOpen(true);
    onOpen?.();
  }, [onOpen]);

  const close = useCallback(() => {
    setIsOpen(false);
    onClose?.();
  }, [onClose]);

  const toggle = useCallback(() => {
    isOpen ? close() : open();
  }, [isOpen, open, close]);

  // ... Ï∂îÍ∞Ä Î°úÏßÅÎì§
}
```

#### 2. Ïô∏Î∂Ä ÌÅ¥Î¶≠ Í∞êÏßÄ
```typescript
// Ïô∏Î∂Ä ÌÅ¥Î¶≠ Í∞êÏßÄ Î°úÏßÅ
useEffect(() => {
  if (!closeOnOutsideClick || !isOpen) return;

  const handleClickOutside = (event: MouseEvent | TouchEvent) => {
    const target = event.target as Node;
    
    // Î©îÎâ¥ÎÇò Î≤ÑÌäº ÎÇ¥Î∂Ä ÌÅ¥Î¶≠Ïù¥ ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Îã´Í∏∞
    if (
      menuRef.current &&
      buttonRef.current &&
      !menuRef.current.contains(target) &&
      !buttonRef.current.contains(target)
    ) {
      close();
    }
  };

  document.addEventListener('mousedown', handleClickOutside);
  document.addEventListener('touchstart', handleClickOutside);
  
  return () => {
    document.removeEventListener('mousedown', handleClickOutside);
    document.removeEventListener('touchstart', handleClickOutside);
  };
}, [isOpen, closeOnOutsideClick, close]);
```

#### 3. ÌÇ§Î≥¥Îìú Ï†ëÍ∑ºÏÑ±
```typescript
// ESC ÌÇ§Î°ú Î©îÎâ¥ Îã´Í∏∞
useEffect(() => {
  if (!closeOnEscape || !isOpen) return;

  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'Escape') {
      event.preventDefault();
      close();
      // Ìè¨Ïª§Ïä§Î•º Î≤ÑÌäºÏúºÎ°ú ÎêòÎèåÎ¶¨Í∏∞
      buttonRef.current?.focus();
    }
  };

  document.addEventListener('keydown', handleKeyDown);
  return () => document.removeEventListener('keydown', handleKeyDown);
}, [isOpen, closeOnEscape, close]);
```

#### 4. Ìè¨Ïª§Ïä§ Ìä∏Îû© (ÏÑ†ÌÉùÏÇ¨Ìï≠)
```typescript
// Ìè¨Ïª§Ïä§ Ìä∏Îû© Íµ¨ÌòÑ
useEffect(() => {
  if (!trapFocus || !isOpen || !menuRef.current) return;

  const menu = menuRef.current;
  const focusableElements = menu.querySelectorAll(
    'a[href], button:not([disabled]), textarea:not([disabled]), input:not([disabled]), select:not([disabled]), [tabindex]:not([tabindex="-1"])'
  );
  
  const firstElement = focusableElements[0] as HTMLElement;
  const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

  const handleTabKey = (event: KeyboardEvent) => {
    if (event.key !== 'Tab') return;

    if (event.shiftKey) {
      if (document.activeElement === firstElement) {
        event.preventDefault();
        lastElement?.focus();
      }
    } else {
      if (document.activeElement === lastElement) {
        event.preventDefault();
        firstElement?.focus();
      }
    }
  };

  menu.addEventListener('keydown', handleTabKey);
  firstElement?.focus(); // Î©îÎâ¥ Ïó¥Î¶¥ Îïå Ï≤´ Î≤àÏß∏ ÏöîÏÜåÏóê Ìè¨Ïª§Ïä§

  return () => {
    menu.removeEventListener('keydown', handleTabKey);
  };
}, [isOpen, trapFocus]);
```

#### 5. Props ÏÉùÏÑ±Í∏∞
```typescript
const getMenuProps = useCallback(() => ({
  ref: menuRef,
  role: 'menu',
  'aria-hidden': !isOpen,
  'data-menu-overlay': true,
  tabIndex: isOpen ? 0 : -1,
}), [isOpen]);

const getButtonProps = useCallback(() => ({
  ref: buttonRef,
  'aria-expanded': isOpen,
  'aria-haspopup': 'menu' as const,
  'data-menu-button': true,
  onClick: toggle,
}), [isOpen, toggle]);
```

## ‚úÖ ÏàòÌñâ ÏûëÏóÖ (Acceptance Criteria)

### 1. Hook Í∏∞Î≥∏ Íµ¨Ï°∞ Íµ¨ÌòÑ
- [ ] `src/hooks/useMenuToggle.ts` ÌååÏùº ÏÉùÏÑ±
- [ ] Í∏∞Î≥∏ ÏÉÅÌÉú Í¥ÄÎ¶¨ Î°úÏßÅ Íµ¨ÌòÑ
- [ ] open, close, toggle Ìï®Ïàò Íµ¨ÌòÑ

### 2. Ï†ëÍ∑ºÏÑ± Í∏∞Îä• Íµ¨ÌòÑ
- [ ] Ïô∏Î∂Ä ÌÅ¥Î¶≠ÏúºÎ°ú Î©îÎâ¥ Îã´Í∏∞
- [ ] ESC ÌÇ§Î°ú Î©îÎâ¥ Îã´Í∏∞
- [ ] ARIA ÏÜçÏÑ± ÏûêÎèô ÏÑ§Ï†ï
- [ ] Ìè¨Ïª§Ïä§ Í¥ÄÎ¶¨ (ÏÑ†ÌÉùÏÇ¨Ìï≠)

### 3. ÏòµÏÖò ÏãúÏä§ÌÖú Íµ¨ÌòÑ
- [ ] ÏÑ§Ï†ï Í∞ÄÎä•Ìïú ÏòµÏÖòÎì§ Ï†ïÏùò
- [ ] Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
- [ ] ÏΩúÎ∞± Ìï®Ïàò ÏßÄÏõê

### 4. TypeScript ÌÉÄÏûÖ Ï†ïÏùò
- [ ] Hook Ïù∏ÌÑ∞ÌéòÏù¥Ïä§ Ï†ïÏùò
- [ ] ÏòµÏÖò ÌÉÄÏûÖ Ï†ïÏùò
- [ ] Î∞òÌôò Í∞í ÌÉÄÏûÖ Ï†ïÏùò

### 5. Header Ïª¥Ìè¨ÎÑåÌä∏ Î¶¨Ìå©ÌÜ†ÎßÅ
- [ ] Í∏∞Ï°¥ Î©îÎâ¥ Î°úÏßÅ Ï†úÍ±∞
- [ ] useMenuToggle Hook Ï†ÅÏö©
- [ ] ÎèôÏùºÌïú Í∏∞Îä• Î≥¥Ïû•

## üîß Íµ¨ÌòÑ ÏÉÅÏÑ∏ÏÇ¨Ìï≠

### ÏôÑÏ†ÑÌïú Hook Íµ¨ÌòÑ
```typescript
// src/hooks/useMenuToggle.ts
import { useState, useRef, useEffect, useCallback } from 'react';

export interface UseMenuToggleOptions {
  initialOpen?: boolean;
  closeOnOutsideClick?: boolean;
  closeOnEscape?: boolean;
  trapFocus?: boolean;
  onOpen?: () => void;
  onClose?: () => void;
}

export interface MenuProps {
  ref: React.RefObject<HTMLElement>;
  role: string;
  'aria-hidden': boolean;
  'data-menu-overlay': boolean;
  tabIndex: number;
}

export interface ButtonProps {
  ref: React.RefObject<HTMLElement>;
  'aria-expanded': boolean;
  'aria-haspopup': 'menu';
  'data-menu-button': boolean;
  onClick: () => void;
}

export interface UseMenuToggleReturn {
  isOpen: boolean;
  open: () => void;
  close: () => void;
  toggle: () => void;
  menuRef: React.RefObject<HTMLElement>;
  buttonRef: React.RefObject<HTMLElement>;
  getMenuProps: () => MenuProps;
  getButtonProps: () => ButtonProps;
}

export function useMenuToggle(options: UseMenuToggleOptions = {}): UseMenuToggleReturn {
  // Íµ¨ÌòÑ ÎÇ¥Ïö©...
}
```

### Header Ïª¥Ìè¨ÎÑåÌä∏ Ï†ÅÏö© ÏòàÏãú
```typescript
// src/components/Header.tsx (After)
import { useMenuToggle } from '@/hooks/useMenuToggle';

export default function Header() {
  const { isOpen, getMenuProps, getButtonProps } = useMenuToggle({
    closeOnOutsideClick: true,
    closeOnEscape: true,
    onClose: () => console.log('Menu closed'),
  });

  return (
    <header className="...">
      {/* ÌñÑÎ≤ÑÍ±∞ Î©îÎâ¥ Î≤ÑÌäº */}
      <button
        {...getButtonProps()}
        className="md:hidden"
      >
        <MenuIcon />
      </button>

      {/* Î™®Î∞îÏùº Î©îÎâ¥ */}
      {isOpen && (
        <div
          {...getMenuProps()}
          className="fixed inset-0 top-20 bg-white z-40"
        >
          <nav className="p-4">
            {navItems.map((item) => (
              <Link key={item.href} href={item.href}>
                {item.name}
              </Link>
            ))}
          </nav>
        </div>
      )}
    </header>
  );
}
```

## üß™ ÌÖåÏä§Ìä∏ Ï†ÑÎûµ

### Unit ÌÖåÏä§Ìä∏
```typescript
// src/hooks/__tests__/useMenuToggle.test.ts
import { renderHook, act } from '@testing-library/react';
import { useMenuToggle } from '../useMenuToggle';

describe('useMenuToggle', () => {
  it('should initialize with closed state', () => {
    const { result } = renderHook(() => useMenuToggle());
    expect(result.current.isOpen).toBe(false);
  });

  it('should toggle menu state', () => {
    const { result } = renderHook(() => useMenuToggle());
    
    act(() => {
      result.current.toggle();
    });
    
    expect(result.current.isOpen).toBe(true);
    
    act(() => {
      result.current.toggle();
    });
    
    expect(result.current.isOpen).toBe(false);
  });

  it('should call onOpen callback when opening', () => {
    const onOpen = jest.fn();
    const { result } = renderHook(() => useMenuToggle({ onOpen }));
    
    act(() => {
      result.current.open();
    });
    
    expect(onOpen).toHaveBeenCalledTimes(1);
  });

  it('should close menu on outside click', () => {
    const { result } = renderHook(() => useMenuToggle({ 
      closeOnOutsideClick: true 
    }));
    
    act(() => {
      result.current.open();
    });
    
    expect(result.current.isOpen).toBe(true);
    
    // Ïô∏Î∂Ä ÌÅ¥Î¶≠ ÏãúÎÆ¨Î†àÏù¥ÏÖò
    act(() => {
      const event = new MouseEvent('mousedown', {
        bubbles: true,
        cancelable: true,
      });
      document.dispatchEvent(event);
    });
    
    expect(result.current.isOpen).toBe(false);
  });
});
```

### ÌÜµÌï© ÌÖåÏä§Ìä∏
```typescript
// src/components/__tests__/Header.integration.test.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import Header from '../Header';

describe('Header with useMenuToggle', () => {
  it('should open and close menu on button click', () => {
    render(<Header />);
    
    const menuButton = screen.getByRole('button', { 
      name: /menu/i 
    });
    
    // Î©îÎâ¥ Ïó¥Í∏∞
    fireEvent.click(menuButton);
    expect(screen.getByRole('menu')).toBeInTheDocument();
    
    // Î©îÎâ¥ Îã´Í∏∞
    fireEvent.click(menuButton);
    expect(screen.queryByRole('menu')).not.toBeInTheDocument();
  });

  it('should close menu on ESC key', () => {
    render(<Header />);
    
    const menuButton = screen.getByRole('button', { 
      name: /menu/i 
    });
    
    fireEvent.click(menuButton);
    expect(screen.getByRole('menu')).toBeInTheDocument();
    
    fireEvent.keyDown(document, { key: 'Escape' });
    expect(screen.queryByRole('menu')).not.toBeInTheDocument();
  });
});
```

## üìä ÏÑ±Îä• Í≥†Î†§ÏÇ¨Ìï≠

### Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ
- Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Ï†ÅÏ†àÌïú Ï†ïÎ¶¨
- useCallbackÏúºÎ°ú Î∂àÌïÑÏöîÌïú Ìï®Ïàò Ïû¨ÏÉùÏÑ± Î∞©ÏßÄ
- useEffect cleanup Ìï®Ïàò Ï≤†Ï†ÄÌïú Íµ¨ÌòÑ

### Î¶¨Î†åÎçîÎßÅ ÏµúÏ†ÅÌôî
```typescript
// Ìï®ÏàòÎì§ÏùÑ useCallbackÏúºÎ°ú Î©îÎ™®Ìôî
const open = useCallback(() => {
  setIsOpen(true);
  onOpen?.();
}, [onOpen]);

// Props Í∞ùÏ≤¥Î•º useMemoÎ°ú Î©îÎ™®Ìôî (Ï∂îÍ∞Ä ÏµúÏ†ÅÌôî)
const menuProps = useMemo(() => ({
  ref: menuRef,
  role: 'menu',
  'aria-hidden': !isOpen,
  'data-menu-overlay': true,
  tabIndex: isOpen ? 0 : -1,
}), [isOpen]);
```

## üö® Î¶¨Ïä§ÌÅ¨ Î∞è ÎåÄÏùëÎ∞©Ïïà

### Medium Risk: Î∏åÎùºÏö∞Ï†Ä Ìò∏ÌôòÏÑ±
- **Î¨∏Ï†ú**: ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ÎÇò Ìè¨Ïª§Ïä§ Í¥ÄÎ¶¨Í∞Ä ÏùºÎ∂Ä Î∏åÎùºÏö∞Ï†ÄÏóêÏÑú Îã§Î•¥Í≤å ÎèôÏûë
- **ÎåÄÏùë**: Î∏åÎùºÏö∞Ï†ÄÎ≥Ñ ÌÖåÏä§Ìä∏ Î∞è Ìè¥Î¶¨ÌïÑ Ï†ÅÏö©

### Low Risk: ÏÑ±Îä• ÏòÅÌñ•
- **Î¨∏Ï†ú**: Îã§ÏàòÏùò Ïù¥Î≤§Ìä∏ Î¶¨Ïä§ÎÑà Îì±Î°ùÏúºÎ°ú Ïù∏Ìïú ÏÑ±Îä• Ï†ÄÌïò
- **ÎåÄÏùë**: Î©îÎâ¥Í∞Ä Ïó¥Î†§ÏûàÏùÑ ÎïåÎßå Î¶¨Ïä§ÎÑà Îì±Î°ù, Ïì∞Î°úÌãÄÎßÅ Ï†ÅÏö©

## üìã Ï≤¥ÌÅ¨Î¶¨Ïä§Ìä∏

### Íµ¨ÌòÑ
- [ ] useMenuToggle Hook Í∏∞Î≥∏ Íµ¨Ï°∞
- [ ] Ïô∏Î∂Ä ÌÅ¥Î¶≠ Í∞êÏßÄ Î°úÏßÅ
- [ ] ÌÇ§Î≥¥Îìú Ï†ëÍ∑ºÏÑ± Íµ¨ÌòÑ
- [ ] TypeScript ÌÉÄÏûÖ Ï†ïÏùò
- [ ] Props ÏÉùÏÑ±Í∏∞ Íµ¨ÌòÑ

### ÌÖåÏä§Ìä∏
- [ ] Unit ÌÖåÏä§Ìä∏ ÏûëÏÑ±
- [ ] ÌÜµÌï© ÌÖåÏä§Ìä∏ ÏûëÏÑ±
- [ ] Ï†ëÍ∑ºÏÑ± ÌÖåÏä§Ìä∏
- [ ] Î∏åÎùºÏö∞Ï†Ä Ìò∏ÌôòÏÑ± ÌÖåÏä§Ìä∏

### Ï†ÅÏö©
- [ ] Header Ïª¥Ìè¨ÎÑåÌä∏ Î¶¨Ìå©ÌÜ†ÎßÅ
- [ ] Í∏∞Îä• ÎèôÏùºÏÑ± ÌôïÏù∏
- [ ] ÏÑ±Îä• Ï∏°Ï†ï Î∞è ÎπÑÍµê

## üéØ ÏôÑÎ£å Í∏∞Ï§Ä (Definition of Done)

- [ ] useMenuToggle HookÏù¥ ÏôÑÏ†ÑÌûà Íµ¨ÌòÑÎê®
- [ ] Î™®Îì† Ï†ëÍ∑ºÏÑ± Í∏∞Îä•Ïù¥ Ï†ïÏÉÅ ÎèôÏûëÌï®
- [ ] Header Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Î¶¨Ìå©ÌÜ†ÎßÅÎê®
- [ ] Í∏∞Ï°¥ Í∏∞Îä•Í≥º 100% ÎèôÏùºÌïú ÎèôÏûë Î≥¥Ïû•
- [ ] ÌÖåÏä§Ìä∏ Ïª§Î≤ÑÎ¶¨ÏßÄ 90% Ïù¥ÏÉÅ Îã¨ÏÑ±
- [ ] ÏÑ±Îä• ÌöåÍ∑Ä ÏóÜÏùå ÌôïÏù∏

## üîó Îã§Ïùå Story Ïó∞Í≤∞Ï†ê

Ïù¥ Story ÏôÑÎ£å ÌõÑ:
- **Story 4.2**: useScrollDirection HookÏúºÎ°ú Ïä§ÌÅ¨Î°§ Í∞êÏßÄ Î°úÏßÅ Ï∂îÏ∂ú
- **Story 4.3**: Í∏∞ÌÉÄ Í≥µÌÜµ HookÎì§ (useLocalStorage, useMediaQuery Îì±) Íµ¨ÌòÑ

---

**Îã¥ÎãπÏûê**: TBD  
**ÏÉùÏÑ±Ïùº**: 2025-01-28  
**ÎßàÏßÄÎßâ ÏóÖÎç∞Ïù¥Ìä∏**: 2025-01-28