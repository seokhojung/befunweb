# 리팩토링 스터디 - 코드 구조화 기법들

## 1. **Modular Architecture (모듈식 아키텍처)**
**개념**: 시스템을 독립적인 모듈로 분리하여 관리
**우리 프로젝트 예시**: 
```
components/
├── cards/      # 카드 관련 컴포넌트 모듈
├── icons/      # 아이콘 컴포넌트 모듈  
├── layout/     # 레이아웃 컴포넌트 모듈
├── sections/   # 페이지 섹션 모듈
└── ui/         # 재사용 UI 컴포넌트 모듈
```

## 2. **Atomic Design (아토믹 디자인)**
**개념**: UI를 원자→분자→유기체→템플릿→페이지 순으로 구성
**우리 프로젝트 예시**:
- **Atoms**: Button.tsx, Badge.tsx (ui 폴더)
- **Molecules**: ProductCard.tsx (cards 폴더)
- **Organisms**: HeroSection.tsx (sections 폴더)
- **Templates**: Layout.tsx (layout 폴더)

## 3. **Single Responsibility Principle (단일 책임 원칙)**
**개념**: 각 컴포넌트는 하나의 명확한 책임만 가짐
**우리 프로젝트 예시**:
- `ProductCard.tsx` → 제품 카드 표시만 담당
- `ColorSwatches` → 색상 견본 표시만 담당
- `generateDummyImage` → 더미 이미지 생성만 담당

## 4. **Barrel Exports (배럴 익스포트)**
**개념**: index.ts 파일로 모듈의 내보내기를 중앙화
**우리 프로젝트 예시**:
```typescript
// components/cards/index.ts
export { ProductCard } from './ProductCard';
export { CategoryCard } from './CategoryCard';
```

## 5. **Composition over Inheritance (상속보다 합성)**
**개념**: 기능을 상속보다는 조합으로 구현
**우리 프로젝트 예시**:
```typescript
// ProductCard 내부에서 ColorSwatches 조합
<ColorSwatches colors={5} additional={10} />
```

## 6. **Feature-Based Organization (기능 기반 조직화)**
**개념**: 기술별이 아닌 기능/도메인별로 파일 구조화
**우리 프로젝트 예시**:
- `cards/` → 카드 관련 모든 것
- `sections/` → 페이지 섹션 관련 모든 것

## 7. **Separation of Concerns (관심사 분리)**
**개념**: 다른 책임들을 다른 모듈로 분리
**우리 프로젝트 예시**:
- `layout/` → 레이아웃 관심사
- `icons/` → 아이콘 관심사  
- `ui/` → 기본 UI 컴포넌트 관심사

## 8. **Pure Functions (순수 함수)**
**개념**: 부작용 없이 입력에 대해 항상 동일한 출력 반환
**우리 프로젝트 예시**:
```typescript
function getFurnitureColor(category?: string): string {
  // category 입력에 대해 항상 동일한 색상 반환
}
```

## 9. **Component Abstraction (컴포넌트 추상화)**
**개념**: 공통된 패턴을 재사용 가능한 컴포넌트로 추출
**우리 프로젝트 예시**:
- `Card.tsx` → 기본 카드 추상화
- `Button.tsx` → 버튼 추상화
- `Badge.tsx` → 배지 추상화

## 10. **Props Interface Design (Props 인터페이스 설계)**
**개념**: 컴포넌트 API를 명확하고 타입 안전하게 설계
**우리 프로젝트 예시**:
```typescript
interface ProductCardProps {
  product: Product;
  className?: string;
}
```

이러한 기법들을 통해 코드의 **가독성**, **유지보수성**, **재사용성**, **테스트 용이성**을 크게 향상시킬 수 있습니다.